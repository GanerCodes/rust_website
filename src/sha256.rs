#![allow(warnings)]

use crate::utils::{bytesToHex};
use std::mem::transmute;

static K: [u32; 64] = [
    0b01000010100010100010111110011000,
    0b01110001001101110100010010010001,
    0b10110101110000001111101111001111,
    0b11101001101101011101101110100101,
    0b00111001010101101100001001011011,
    0b01011001111100010001000111110001,
    0b10010010001111111000001010100100,
    0b10101011000111000101111011010101,
    0b11011000000001111010101010011000,
    0b00010010100000110101101100000001,
    0b00100100001100011000010110111110,
    0b01010101000011000111110111000011,
    0b01110010101111100101110101110100,
    0b10000000110111101011000111111110,
    0b10011011110111000000011010100111,
    0b11000001100110111111000101110100,
    0b11100100100110110110100111000001,
    0b11101111101111100100011110000110,
    0b00001111110000011001110111000110,
    0b00100100000011001010000111001100,
    0b00101101111010010010110001101111,
    0b01001010011101001000010010101010,
    0b01011100101100001010100111011100,
    0b01110110111110011000100011011010,
    0b10011000001111100101000101010010,
    0b10101000001100011100011001101101,
    0b10110000000000110010011111001000,
    0b10111111010110010111111111000111,
    0b11000110111000000000101111110011,
    0b11010101101001111001000101000111,
    0b00000110110010100110001101010001,
    0b00010100001010010010100101100111,
    0b00100111101101110000101010000101,
    0b00101110000110110010000100111000,
    0b01001101001011000110110111111100,
    0b01010011001110000000110100010011,
    0b01100101000010100111001101010100,
    0b01110110011010100000101010111011,
    0b10000001110000101100100100101110,
    0b10010010011100100010110010000101,
    0b10100010101111111110100010100001,
    0b10101000000110100110011001001011,
    0b11000010010010111000101101110000,
    0b11000111011011000101000110100011,
    0b11010001100100101110100000011001,
    0b11010110100110010000011000100100,
    0b11110100000011100011010110000101,
    0b00010000011010101010000001110000,
    0b00011001101001001100000100010110,
    0b00011110001101110110110000001000,
    0b00100111010010000111011101001100,
    0b00110100101100001011110010110101,
    0b00111001000111000000110010110011,
    0b01001110110110001010101001001010,
    0b01011011100111001100101001001111,
    0b01101000001011100110111111110011,
    0b01110100100011111000001011101110,
    0b01111000101001010110001101101111,
    0b10000100110010000111100000010100,
    0b10001100110001110000001000001000,
    0b10010000101111101111111111111010,
    0b10100100010100000110110011101011,
    0b10111110111110011010001111110111,
    0b11000110011100010111100011110010
];
static INIT: [u32; 8] = [
    0b01101010000010011110011001100111,
    0b10111011011001111010111010000101,
    0b00111100011011101111001101110010,
    0b10100101010011111111010100111010,
    0b01010001000011100101001001111111,
    0b10011011000001010110100010001100,
    0b00011111100000111101100110101011,
    0b01011011111000001100110100011001
];

fn σ0(n: u32) -> u32 { n.rotate_right(7) ^ n.rotate_right(18) ^ (n >> 3) }
fn σ1(n: u32) -> u32 { n.rotate_right(17) ^ n.rotate_right(19) ^ (n >> 10) }
fn Σ0(n: u32) -> u32 { n.rotate_right(2) ^ n.rotate_right(13) ^ n.rotate_right(22) }
fn Σ1(n: u32) -> u32 { n.rotate_right(6) ^ n.rotate_right(11) ^ n.rotate_right(25) }
fn choice(x: u32, y: u32, z: u32) -> u32 { (x & y) | (!x & z) }
fn majority(x: u32, y: u32, z: u32) -> u32 { (x & y) | (y & z) | (z & x) }
fn sha256_from_schedule(msgSchedule: [u32; 64], init: [u32; 8]) -> [u32; 8] {
    let mut W = init.clone();
    for i in 0..64 {
        let T1 = Σ1(W[4])
        .wrapping_add(choice(W[4], W[5], W[6]))
        .wrapping_add(W[7])
        .wrapping_add(K[i])
        .wrapping_add(msgSchedule[i]);
        
        let T2 = Σ0(W[0]).wrapping_add(majority(W[0], W[1], W[2]));
        W[7] = W[6];
        W[6] = W[5];
        W[5] = W[4];
        W[4] = W[3].wrapping_add(T1);
        W[3] = W[2];
        W[2] = W[1];
        W[1] = W[0];
        W[0] = T1.wrapping_add(T2);
    }
    for i in 0..8 {
        W[i] = W[i].wrapping_add(init[i]);
    }
    W
}
fn sha256_from_block(block: [u32; 16], init: [u32; 8]) -> [u32; 8] {
    let mut msgSchedule: [u32; 64] = [0; 64];
    for i in 0..16 {
        msgSchedule[i] = block[i];
    }
    for i in 16..64 {
        msgSchedule[i] = σ1(msgSchedule[i - 2])
        .wrapping_add(   msgSchedule[i - 7 ])
        .wrapping_add(σ0(msgSchedule[i - 15]))
        .wrapping_add(   msgSchedule[i - 16]);
    }
    sha256_from_schedule(msgSchedule, init)
}

pub fn sha256(data: &[u8]) -> String {
    let mut buffer: [u32; 8] = INIT.clone();
    
    let mut u32_block: [u32; 16] = [0; 16];
    let mut blockCount = 0;
    let bitCount = 8 * data.len();
    let padding = 448 + 512 * (bitCount / 448) - (bitCount + 1);
    let totalBitCount   = bitCount + 1 + padding + 64;
    let totalBlockCount = totalBitCount / 512;
    
    for i in 0..totalBitCount {
        let bit = match i {
            i if i < bitCount => { (1 & (data[i / 8] >> (7 - i % 8))) as u32 },
            i if i == bitCount => 1u32,
            _ => { continue; }
        };
        u32_block[(i / 32) % 16] |= (bit as u32) << (31 - i % 32);
        if blockCount < totalBlockCount - 1 && (i + 1) % 512 == 0 {
            buffer = sha256_from_block(u32_block, buffer);
            u32_block = [0u32; 16];
            blockCount += 1;
        }
    }
    
    u32_block[15] = bitCount as u32; //oh no I can only hash 512gb of data correctly
    buffer = sha256_from_block(u32_block, buffer);
    
    let mut result = String::new();
    for i in buffer {
        let bytes: [u8; 4] = unsafe {
            transmute(i.to_be())
        };
        result.push_str(&bytesToHex(bytes.to_vec()));
    }
    return result;
}